# 開放API規範

#### 版本 3.0.0

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [BCP 14](https://tools.ietf.org/html/bcp14) [RFC2119](https://tools.ietf.org/html/rfc2119) [RFC8174](https://tools.ietf.org/html/rfc8174) when, and only when, they appear in all capitals, as shown here.

This document is licensed under [The Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html).

## 介紹

The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.

An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.

## 目錄
<!-- TOC depthFrom:1 depthTo:3 withLinks:1 updateOnSave:1 orderedList:0 -->

- [定義](#definitions)
	- [開放API文檔](#oasDocument)
	- [路徑模板](#pathTemplating)
	- [媒體類型](#mediaTypes)
	- [HTTP 狀態碼](#httpCodes)
- [規範](#specification)
	- [版本](#versions)
	- [格式](#format)
	- [文檔結構](#documentStructure)
	- [數據類型](#dataTypes)
	- [富文本格式](#richText)
	- [相對引用](#relativeReferences)
	- [綱要](#schema)
		- [OpenAPI 對象](#oasObject)
		- [Info 對象](#infoObject)
		- [Contact 對象](#contactObject)
		- [License 對象](#licenseObject)
		- [Server 對象](#serverObject)
		- [Server Variable 對象](#serverVariableObject)
		- [Components 對象](#componentsObject)
		- [Paths 對象](#pathsObject)
		- [Path Item 對象](#pathItemObject)
		- [Operation 對象](#operationObject)
		- [External Documentation 對象](#externalDocumentationObject)
		- [Parameter 對象](#parameterObject)
		- [Request Body 對象](#requestBodyObject)
		- [Media Type 對象](#mediaTypeObject)
		- [Encoding 對象](#encodingObject)
		- [Responses 對象](#responsesObject)
		- [Response 對象](#responseObject)
		- [Callback 對象](#callbackObject)
		- [Example 對象](#exampleObject)
		- [Link 對象](#linkObject)
		- [Header 對象](#headerObject)
		- [Tag 對象](#tagObject)
		- [Reference 對象](#referenceObject)
		- [Schema 對象](#schemaObject)
		- [Discriminator 對象](#discriminatorObject)
		- [XML 對象](#xmlObject)
		- [Security Scheme 對象](#securitySchemeObject)
		- [OAuth Flows 對象](#oauthFlowsObject)
		- [OAuth Flow 對象](#oauthFlowObject)
		- [Security Requirement 對象](#securityRequirementObject)
	- [規範擴展](#specificationExtensions)
	- [Security Filtering](#securityFiltering)
- [附錄 A: 修訂歷史](#revisionHistory)


<!-- /TOC -->

## <a name="definitions"></a>術語定義

##### <a name="oasDocument"></a>開放API文檔

一（或多）份用來定義或描述一個API的文檔。

##### <a name="pathTemplating"></a>路徑模板

路徑模板指用大括號標記來標記一段URL作為可替換的路徑參數。

##### <a name="mediaTypes"></a>媒體類型

媒體類型定義分散於多處。
媒體類型定義應當符合[RFC6838](http://tools.ietf.org/html/rfc6838)。

以下是一些媒體類型定義的示例：
```
  text/plain; charset=utf-8
  application/json
  application/vnd.github+json
  application/vnd.github.v3+json
  application/vnd.github.v3.raw+json
  application/vnd.github.v3.text+json
  application/vnd.github.v3.html+json
  application/vnd.github.v3.full+json
  application/vnd.github.v3.diff
  application/vnd.github.v3.patch
```
##### <a name="httpCodes"></a>HTTP狀態碼

HTTP狀態碼被用來表示一次請求的被執行狀態。
[RFC7231](http://tools.ietf.org/html/rfc7231#section-6)定義了有效的狀態碼，可以在[IANA Status Code Registry](http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)找到已經被註冊的狀態碼的列表。

## <a name="specification"></a>規範

### <a name="versions"></a>版本

開放API規範使用符合[語義化版本 2.0.0](http://semver.org/spec/v2.0.0.html)(semver)規範的版本號。

語義化版本的`主版本號`、`次版本號`部分（比如`3.0`）應當被用來標記開放API規範的特性變動。通常 *`.修訂號`* 版本被用來表示本文檔文檔的錯誤修正而不是特性變動。支持開放API規範3.0的工具應該兼容所有3.0.\*的版本，工具不應當關注修訂版本號，比如`3.0.0`和`3.0.1`對它來說應該沒有任何區別。

此後開放API規範的相同主版本號下更高次要版本的發佈不應當對面向低於此次要版本號開發的工具的造成干擾。因此`3.1.0`版本的規範應當可以在面向`3.0.0`版本規範開發的工具內使用。

任何兼容開放API規範 3.\*.\* 的文檔應當包含一個[`openapi`](#oasVersion) 字段用來表明它使用的規範的語義化版本。

### Format | 格式

一份遵從開放API規範的文檔是一個自包含的JSON對象，可以使用JSON或YAML格式編寫。

比如一個字段有一組值，用JSON格式表示為：

```json
{
   "field": [ 1, 2, 3 ]
}
```
規範內的所有字段名都是**小寫**。

本綱要提供了兩種類型的字段：固定字段和模式字段，固定字段表示字段有固定的命名，模式字段表示命名需要符合一定的模式。

模式字段必須包含它的對象內的名字必須是唯一的。

為了保留在 YAML 和 JSON 格式之間轉換的能力，推薦使用[1.2](http://www.yaml.org/spec/1.2/spec.html)版本的YAML格式，而且還需要符合以下限制：

- Tags 必須被限制在[JSON Schema ruleset](http://www.yaml.org/spec/1.2/spec.html#id2803231)允許的範圍內。
- Keys 必須是[YAML Failsafe schema ruleset](http://yaml.org/spec/1.2/spec.html#id2802346)規範定義的純字符串。

**注意：** 雖然API文檔是使用 YAML 或 JSON 格式書寫的，但是API的請求體和響應體或者其他內容可以是任何格式。

### <a name="documentStructure"></a>文檔結構

An OpenAPI document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case, `$ref` fields MUST be used in the specification to reference those parts as follows from the [JSON Schema](http://json-schema.org) definitions.

推薦將根開放API文檔命名為`openapi.json` 或 `openapi.yaml`。

### <a name="dataTypes"></a>數據類型

Primitive data types in the OAS are based on the types supported by the [JSON Schema Specification Wright Draft 00](https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2).
Note that `integer` as a type is also supported and is defined as a JSON number without a fraction or exponent part.
`null` is not supported as a type (see [`nullable`](#schemaNullable) for an alternative solution).
Models are defined using the [Schema Object](#schemaObject), which is an extended subset of JSON Schema Specification Wright Draft 00.

<a name="dataTypeFormat"></a>Primitives have an optional modifier property: `format`.
OAS uses several known formats to define in fine detail the data type being used.
However, to support documentation needs, the `format` property is an open `string`-valued property, and can have any value.
Formats such as `"email"`, `"uuid"`, and so on, MAY be used even though undefined by this specification.
Types that are not accompanied by a `format` property follow the type definition in the JSON Schema. Tools that do not recognize a specific `format` MAY default back to the `type` alone, as if the `format` is not specified.

The formats defined by the OAS are:

Common Name | [`type`](#dataTypes) | [`format`](#dataTypeFormat) | Comments
----------- | ------ | -------- | --------
integer | `integer` | `int32` | signed 32 bits
long | `integer` | `int64` | signed 64 bits
float | `number` | `float` | |
double | `number` | `double` | |
string | `string` | | |
byte | `string` | `byte` | base64 encoded characters
binary | `string` | `binary` | any sequence of octets
boolean | `boolean` | | |
date | `string` | `date` | As defined by `full-date` - [RFC3339](http://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)
dateTime | `string` | `date-time` | As defined by `date-time` - [RFC3339](http://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)
password | `string` | `password` | A hint to UIs to obscure input.

### <a name="richText"></a>富文本格式

Throughout the specification `description` fields are noted as supporting CommonMark markdown formatting.
Where OpenAPI tooling renders rich text it MUST support, at a minimum, markdown syntax as described by [CommonMark 0.27](http://spec.commonmark.org/0.27/). Tooling MAY choose to ignore some CommonMark features to address security concerns.

### <a name="relativeReferences"></a>URL的相對引用

Unless specified otherwise, all properties that are URLs MAY be relative references as defined by [RFC3986](https://tools.ietf.org/html/rfc3986#section-4.2).
Relative references are resolved using the URLs defined in the [`Server Object`](#serverObject) as a Base URI.

Relative references used in `$ref` are processed as per [JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03), using the URL of the current document as the base URI. See also the [Reference Object](#referenceObject).

### 綱要

在接下來的敘述中，如果一個字段沒有被明確的標記為 **必選** 或者被描述為 **必須** 或 **應當**，那麼可以認為它是一個 **可選** 字段

#### <a name="oasObject"></a>OpenAPI 對象

這是[OpenAPI document](#oasDocument)的根文檔對象。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="oasVersion"></a>openapi | `string` | **必選**. 這個字符串必須是[開放API規範版本號](#versions)提到的符合[語義化版本號規範](http://semver.org/spec/v2.0.0.html)的版本號。`openapi`字段應該被工具或者客戶端用來解釋開放API文檔。這個值和API [`info.version`](#infoVersion)字符串沒有關聯。
<a name="oasInfo"></a>info | [Info 對象](#infoObject) | **必選**。此字段提供API相關的元數據。相關工具可能需要這個字段。
<a name="oasServers"></a>servers | [[Server 對象](#serverObject)] | 這是一個Server對象的數組， 提供到服務器的連接信息。如果沒有提供`servers`屬性或者是一個空數組，那麼默認為是[url](#serverUrl)值為`/`的 [Server 對象](#serverObject) 。
<a name="oasPaths"></a>paths | [Paths 對象](#pathsObject) | **必選**。對所提供的API有效的路徑和操作。
<a name="oasComponents"></a>components | [Components 對象](#componentsObject) | 一個包含多種綱要的元素。
<a name="oasSecurity"></a>security | [[Security Requirement 對象](#securityRequirementObject)] | 聲明API使用的安全機制。The list of values includes alternative security requirement objects that can be used. 認證一個請求時僅允許使用一種安全機制。單獨的操作可以覆蓋這裡的定義。
<a name="oasTags"></a>tags | [[Tag 對象](#tagObject)] | 提供更多元數據的一系列標籤，標籤的順序可以被轉換工具用來決定API的順序。不是所有被[Operation 對象](#operationObject)用到的標籤都必須被聲明。沒有被聲明的標籤可能被工具按自己的邏輯任意整理，每個標籤名都應該是唯一的。
<a name="oasExternalDocs"></a>externalDocs | [External Documentation 對象](#externalDocumentationObject) | 附加的文檔。這個對象可能會被[規範擴展](#specificationExtensions)擴展。


#### <a name="infoObject"></a>Info 對象

這個對象提供API的元數據。如果客戶端需要時可能會用到這些元數據，而且可能會被呈現在編輯工具或者文檔生成工具中。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="infoTitle"></a>title | `string` | **必選**. 應用的名稱。
<a name="infoDescription"></a>description | `string` | 對應用的簡短描述。 [CommonMark syntax](http://spec.commonmark.org/) 可以被用來表示富文本呈現。
<a name="infoTermsOfService"></a>termsOfService | `string` | 指向服務條款的URL地址，必須是URL地址格式。
<a name="infoContact"></a>contact | [Contact Object](#contactObject) | 所開放的API的聯繫人信息。
<a name="infoLicense"></a>license | [License Object](#licenseObject) | 所開放的API的證書信息。
<a name="infoVersion"></a>version | `string` | **必選**. API文檔的版本信息（注意：這個版本和[開放API規範版本](#oasVersion)沒有任何關係）。


##### Info 對象示例:

```json
{
  "title": "Sample Pet Store App",
  "description": "This is a sample server for a pet store.",
  "termsOfService": "http://example.com/terms/",
  "contact": {
    "name": "API Support",
    "url": "http://www.example.com/support",
    "email": "support@example.com"
  },
  "license": {
    "name": "Apache 2.0",
    "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
  },
  "version": "1.0.1"
}
```

```yaml
title: Sample Pet Store App
description: This is a sample server for a pet store.
termsOfService: http://example.com/terms/
contact:
  name: API Support
  url: http://www.example.com/support
  email: support@example.com
license:
  name: Apache 2.0
  url: http://www.apache.org/licenses/LICENSE-2.0.html
version: 1.0.1
```

#### <a name="contactObject"></a>Contact 對象

所公開的API的聯繫人信息

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="contactName"></a>name | `string` | 人或組織的名稱。
<a name="contactUrl"></a>url | `string` | 指向聯繫人信息的URL地址，必須是URL地址格式。
<a name="contactEmail"></a>email | `string` | 人或組織的email地址，必須是email地址格式。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Contact 對象示例：

```json
{
  "name": "API Support",
  "url": "http://www.example.com/support",
  "email": "support@example.com"
}
```

```yaml
name: API Support
url: http://www.example.com/support
email: support@example.com
```

#### <a name="licenseObject"></a>License 對象

公開API的證書信息。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="licenseName"></a>name | `string` | **必選**. API的證書名。
<a name="licenseUrl"></a>url | `string` | 指向API所使用的證書的URL地址，必須是URL地址格式。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### License 對象示例：

```json
{
  "name": "Apache 2.0",
  "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
}
```

```yaml
name: Apache 2.0
url: http://www.apache.org/licenses/LICENSE-2.0.html
```

#### <a name="serverObject"></a>Server 對象

表示一個服務器的對象。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="serverUrl"></a>url | `string` | **必選**. 指向目標主機的URL地址。這個URL地址支持服務器變量而且可能是相對路徑，表示主機路徑是相對於本文檔所在的路徑。當一個變量被命名為類似`{`brackets`}`時需要替換此變量。
<a name="serverDescription"></a>description | `string` | 一個可選的字符串，用來描述此URL地址。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="serverVariables"></a>variables | Map[`string`, [Server Variable Object](#serverVariableObject)] | 一組變量和值的映射，這些值被用來替換服務器URL地址內的模板參數。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Server 對象示例

單個服務器可以這樣描述：

```json
{
  "url": "https://development.gigantic-server.com/v1",
  "description": "Development server"
}
```

```yaml
url: https://development.gigantic-server.com/v1
description: Development server
```

以下內容表示的是有多個服務器時應該如何描述，比如OpenAPI 對象的[`servers`](#oasServers)：

```json
{
  "servers": [
    {
      "url": "https://development.gigantic-server.com/v1",
      "description": "Development server"
    },
    {
      "url": "https://staging.gigantic-server.com/v1",
      "description": "Staging server"
    },
    {
      "url": "https://api.gigantic-server.com/v1",
      "description": "Production server"
    }
  ]
}
```

```yaml
servers:
- url: https://development.gigantic-server.com/v1
  description: Development server
- url: https://staging.gigantic-server.com/v1
  description: Staging server
- url: https://api.gigantic-server.com/v1
  description: Production server
```

以下內容展示瞭如何使用變量來配置服務器：

```json
{
  "servers": [
    {
      "url": "https://{username}.gigantic-server.com:{port}/{basePath}",
      "description": "The production API server",
      "variables": {
        "username": {
          "default": "demo",
          "description": "this value is assigned by the service provider, in this example `gigantic-server.com`"
        },
        "port": {
          "enum": [
            "8443",
            "443"
          ],
          "default": "8443"
        },
        "basePath": {
          "default": "v2"
        }
      }
    }
  ]
}
```

```yaml
servers:
- url: https://{username}.gigantic-server.com:{port}/{basePath}
  description: The production API server
  variables:
    username:
      # note! no enum here means it is an open value
      default: demo
      description: this value is assigned by the service provider, in this example `gigantic-server.com`
    port:
      enum:
        - '8443'
        - '443'
      default: '8443'
    basePath:
      # open meaning there is the opportunity to use special base paths as assigned by the provider, default is `v2`
      default: v2
```


#### <a name="serverVariableObject"></a>Server Variable 對象

表示可用於服務器URL地址模板變量替換的對象。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="serverVariableEnum"></a>enum | [`string`] | 一組可枚舉字符串值，當可替換選項只能設置為固定的某些值時使用。
<a name="serverVariableDefault"></a>default | `string` |  **必選**. 當可替換的值沒有被使用者指定時使用的默認值。不像[Schema Object's](#schemaObject)的 `default` ，這個值必須由使用者提供。
<a name="serverVariableDescription"></a>description | `string` | 對服務器變量的可選的描述。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

#### <a name="componentsObject"></a>Components 對象

包含開放API規範固定的各種可重用組件。當沒有被其他對象引用時，在這裡定義定義的組件不會產生任何效果。


##### 固定字段

字段名 | 類型 | 描述
---|:---|---
<a name="componentsSchemas"></a> schemas | Map[`string`, [Schema Object](#schemaObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Schema 對象](#schemaObject) 的對象。
<a name="componentsResponses"></a> responses | Map[`string`, [Response Object](#responseObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Response 對象](#responseObject) 的對象。
<a name="componentsParameters"></a> parameters | Map[`string`, [Parameter Object](#parameterObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Parameter 對象](#parameterObject) 的對象。
<a name="componentsExamples"></a> examples | Map[`string`, [Example Object](#exampleObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Example 對象](#exampleObject) 的對象。
<a name="componentsRequestBodies"></a> requestBodies | Map[`string`, [Request Body Object](#requestBodyObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Request Body 對象](#requestBodyObject) 的對象。
<a name="componentsHeaders"></a> headers | Map[`string`, [Header Object](#headerObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Header 對象](#headerObject) 的對象。
<a name="componentsSecuritySchemes"></a> securitySchemes| Map[`string`, [Security Scheme Object](#securitySchemeObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Security Scheme 對象](#securitySchemeObject) 的對象。
<a name="componentsLinks"></a> links | Map[`string`, [Link Object](#linkObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Link 對象](#linkObject) 的對象。
<a name="componentsCallbacks"></a> callbacks | Map[`string`, [Callback Object](#callbackObject) \| [Reference Object](#referenceObject)] | 定義可重用的 [Callback 對象](#callbackObject) 的對象。

這個對象可能會被 [規範擴展](#specificationExtensions) 擴展。

上面定義的所有固定字段的值都是對象，對象包含的key的命名必須滿足正則表達式： `^[a-zA-Z0-9\.\-_]+$`。

字段名示例:

```
User
User_1
User_Name
user-name
my.org.User
```

##### Components 對象示例

```json
"components": {
  "schemas": {
    "Category": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "Tag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    }
  },
  "parameters": {
    "skipParam": {
      "name": "skip",
      "in": "query",
      "description": "number of items to skip",
      "required": true,
      "schema": {
        "type": "integer",
        "format": "int32"
      }
    },
    "limitParam": {
      "name": "limit",
      "in": "query",
      "description": "max records to return",
      "required": true,
      "schema" : {
        "type": "integer",
        "format": "int32"
      }
    }
  },
  "responses": {
    "NotFound": {
      "description": "Entity not found."
    },
    "IllegalInput": {
      "description": "Illegal input for operation."
    },
    "GeneralError": {
      "description": "General Error",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/GeneralError"
          }
        }
      }
    }
  },
  "securitySchemes": {
    "api_key": {
      "type": "apiKey",
      "name": "api_key",
      "in": "header"
    },
    "petstore_auth": {
      "type": "oauth2",
      "flows": {
        "implicit": {
          "authorizationUrl": "http://example.org/api/oauth/dialog",
          "scopes": {
            "write:pets": "modify pets in your account",
            "read:pets": "read your pets"
          }
        }
      }
    }
  }
}
```

```yaml
components:
  schemas:
    Category:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
    Tag:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
  parameters:
    skipParam:
      name: skip
      in: query
      description: number of items to skip
      required: true
      schema:
        type: integer
        format: int32
    limitParam:
      name: limit
      in: query
      description: max records to return
      required: true
      schema:
        type: integer
        format: int32
  responses:
    NotFound:
      description: Entity not found.
    IllegalInput:
      description: Illegal input for operation.
    GeneralError:
      description: General Error
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/GeneralError'
  securitySchemes:
    api_key:
      type: apiKey
      name: api_key
      in: header
    petstore_auth:
      type: oauth2
      flows:
        implicit:
          authorizationUrl: http://example.org/api/oauth/dialog
          scopes:
            write:pets: modify pets in your account
            read:pets: read your pets
```


#### <a name="pathsObject"></a>Paths 對象

定義各個的端點和操作的相對路徑。這裡指定的路徑會和 [`Server 對象`](#serverObject) 內指定的URL地址組成完整的URL地址，路徑可以為空，這依賴於 [ACL constraints](#securityFiltering) 的設置。

##### 模式字段

字段名模式 | 類型 | 描述
---|:---:|---
<a name="pathsPath"></a>/{path} | [Path Item 對象](#pathItemObject) | 到各個端點的相對路徑，路徑必須以`/`打頭，這個路徑會被**直接連接**到 [`Server 對象`](#serverObject) 的`url`字段以組成完整URL地址（不會考慮是否是相對路徑）。這裡可以使用 [Path templating](#pathTemplating) ，當做URL地址匹配時，不帶路徑參數的路徑會被優先匹配。應該避免定義多個具有相同路徑層級但是路徑參數名不同的路徑，因為他們是等價的。當匹配出現歧義時，由使用的工具自行決定使用那個路徑。

個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### 路徑模板匹配

假設有以下路徑，明確定義的路徑 `/pets/mine` 會被優先匹配：

```
  /pets/{petId}
  /pets/mine
```

以下路徑被認為是等價的而且是無效的：

```
  /pets/{petId}
  /pets/{name}
```

以下路徑會產生歧義：

```
  /{entity}/me
  /books/{id}
```

##### Paths 對象示例

```json
{
  "/pets": {
    "get": {
      "description": "Returns all pets from the system that the user has access to",
      "responses": {
        "200": {
          "description": "A list of pets.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/pet"
                }
              }
            }
          }
        }
      }
    }
  }
}
```

```yaml
/pets:
  get:
    description: Returns all pets from the system that the user has access to
    responses:
      '200':
        description: A list of pets.
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/pet'
```

#### <a name="pathItemObject"></a>Path Item 對象

描述對一個路徑可執行的有效操作。依賴與 [ACL constraints](#securityFiltering) 的設置，一個Path Item可以是一個空對象，文檔的讀者仍然可以看到這個路徑，但是他們將無法瞭解到對這個路徑可用的任何操作和參數。


##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="pathItemRef"></a>$ref | `string` | 指定對此路徑的外部定義的引用，引用的格式必須符合 [Path Item 對象](#pathItemObject) 的格式，如果引用的外部定義和此對象內的其他定義有衝突，該如何處理衝突尚未被定義。
<a name="pathItemSummary"></a>summary| `string` | 一個可選的簡要總結字符串，用來描述此路徑內包含的所有操作。
<a name="pathItemDescription"></a>description | `string` | 一個可選的詳細說明字符串，用於描述此路徑包含的所有操作。 [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="pathItemGet"></a>get | [Operation 對象](#operationObject) | 定義適用於此路徑的 GET 操作。
<a name="pathItemPut"></a>put | [Operation 對象](#operationObject) | 定義適用於此路徑的 PUT 操作。
<a name="pathItemPost"></a>post | [Operation 對象](#operationObject) | 定義適用於此路徑的 POST 操作.
<a name="pathItemDelete"></a>delete | [Operation 對象](#operationObject) | 定義適用於此路徑的 DELETE 操作。
<a name="pathItemOptions"></a>options | [Operation 對象](#operationObject) | 定義適用於此路徑的 OPTIONS 操作。
<a name="pathItemHead"></a>head | [Operation 對象](#operationObject) | 定義適用於此路徑的 HEAD 操作。
<a name="pathItemPatch"></a>patch | [Operation 對象](#operationObject) | 定義適用於此路徑的 PATCH 操作。
<a name="pathItemTrace"></a>trace | [Operation 對象](#operationObject) | 定義適用於此路徑的 TRACE 操作。
<a name="pathItemServers"></a>servers | [[Server 對象](#serverObject)] | 一個可用於此路徑所有操作的替代根`server`的數組定義。
<a name="pathItemParameters"></a>parameters | [[Parameter 對象](#parameterObject) \| [Reference 對象](#referenceObject)] | 一個可用於此路徑下所有操作的參數的列表。這些參數可以被具體的操作定義覆蓋，但是不能被移除。這個列表禁止包含重複的參數，一個唯一的參數名由 [name](#parameterName) 和 [location](#parameterIn) 的組合來定義。這個列表可以使用 [Reference ](#referenceObject) 格式引用定義在 [OpenAPI 對象 components/parameters](#componentsParameters) 內的參數。


這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Path Item 對象示例

```json
{
  "get": {
    "description": "Returns pets based on ID",
    "summary": "Find pets by ID",
    "operationId": "getPetsById",
    "responses": {
      "200": {
        "description": "pet response",
        "content": {
          "*/*": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          }
        }
      },
      "default": {
        "description": "error payload",
        "content": {
          "text/html": {
            "schema": {
              "$ref": "#/components/schemas/ErrorModel"
            }
          }
        }
      }
    }
  },
  "parameters": [
    {
      "name": "id",
      "in": "path",
      "description": "ID of pet to use",
      "required": true,
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "style": "simple"
    }
  ]
}
```

```yaml
get:
  description: Returns pets based on ID
  summary: Find pets by ID
  operationId: getPetsById
  responses:
    '200':
      description: pet response
      content:
        '*/*' :
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Pet'
    default:
      description: error payload
      content:
        'text/html':
          schema:
            $ref: '#/components/schemas/ErrorModel'
parameters:
- name: id
  in: path
  description: ID of pet to use
  required: true
  schema:
    type: array
    style: simple
    items:
      type: string
```

#### <a name="operationObject"></a>Operation Object

描述對路徑的某個操作。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="operationTags"></a>tags | [`string`] | 用於控制API文檔的標籤列表，標籤可以用於在邏輯上分組對資源的操作或作為其它用途的先決條件。
<a name="operationSummary"></a>summary | `string` | 對此操作行為的簡短描述。
<a name="operationDescription"></a>description | `string` | 對此操作行為的詳細解釋。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="operationExternalDocs"></a>externalDocs | [External Documentation 對象](#externalDocumentationObject) | 附加的外部文檔。
<a name="operationId"></a>operationId | `string` | 用於標識此操作的唯一字符串，這個id在此API內包含的所有操作中必須是唯一的。相關的工具和庫可能會使用此operationId來唯一的標識一個操作，因此推薦在命名時符合一般的編程命名習慣。
<a name="operationParameters"></a>parameters | [[Parameter 對象](#parameterObject) \| [Reference 對象](#referenceObject)] | 定義可用於此操作的參數列表，如果一個同名的參數已經存在於 [Path Item](#pathItemParameters)，那麼這裡的定義會覆蓋它但是不能移除上面的定義。這個列表不允許包含重複的參數，參數的唯一性由 [name](#parameterName) 和  [location](#parameterIn) 的組合來確定。這個列表可以使用 [Reference 對象](#referenceObject) 來連接定義於 [OpenAPI 對象 components/parameters](#componentsParameters) 的參數。
<a name="operationRequestBody"></a>requestBody | [Request Body 對象](#requestBodyObject) \| [Reference 對象](#referenceObject) | 可用於此操作的請求體。`requestBody` 只能被用於HTTP 1.1 規範 [RFC7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) 中明確定義了包含請求體的請求方法，在其他沒有明確定義的請求方法中，`requestBody`的消費者應該應該忽略`requestBody`。
<a name="operationResponses"></a>responses | [Responses 對象](#responsesObject) | **必選**. 定義執行此操作後的可能的響應值列表。
<a name="operationCallbacks"></a>callbacks | Map[`string`, [Callback 對象](#callbackObject) \| [Reference 對象](#referenceObject)] | 一組相對於父操作的可能出現的回調映射，A map of possible out-of band callbacks related to the parent operation. 映射中的每一個鍵都唯一的映射一個 [Callback 對象](#callbackObject)， that describes a request that may be initiated by the API provider and the expected responses. The key value used to identify the callback object is an expression, evaluated at runtime, that identifies a URL to use for the callback operation.
<a name="operationDeprecated"></a>deprecated | `boolean` | 聲明此操作已經被廢棄，使用者應該儘量避免使用此操作，默認的值是 `false`。
<a name="operationSecurity"></a>security | [[Security Requirement 對象](#securityRequirementObject)] | 聲明那種安全機制可用於此操作。這個列表可以包含多種可用於此操作的安全需求對象，但是在認證一個請求時應該僅使用其中一種。這裡的定義會覆蓋任何在頂層 [`security`](#oasSecurity) 中的安全聲明，因此可以聲明一個空數組來變相的移除頂層的安全聲明。
<a name="operationServers"></a>servers | [[Server 對象](#serverObject)] | 一個可用於此操作的額外的 `server` 數組，這裡的定義會覆蓋 Path Item 對象 或 頂層的定義。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Operation 對象示例

```json
{
  "tags": [
    "pet"
  ],
  "summary": "Updates a pet in the store with form data",
  "operationId": "updatePetWithForm",
  "parameters": [
    {
      "name": "petId",
      "in": "path",
      "description": "ID of pet that needs to be updated",
      "required": true,
      "schema": {
        "type": "string"
      }
    }
  ],
  "requestBody": {
    "content": {
      "application/x-www-form-urlencoded": {
        "schema": {
          "type": "object",
           "properties": {
              "name": {
                "description": "Updated name of the pet",
                "type": "string"
              },
              "status": {
                "description": "Updated status of the pet",
                "type": "string"
             }
           },
        "required": ["status"]
        }
      }
    }
  },
  "responses": {
    "200": {
      "description": "Pet updated.",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    },
    "405": {
      "description": "Invalid input",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    }
  },
  "security": [
    {
      "petstore_auth": [
        "write:pets",
        "read:pets"
      ]
    }
  ]
}
```

```yaml
tags:
- pet
summary: Updates a pet in the store with form data
operationId: updatePetWithForm
parameters:
- name: petId
  in: path
  description: ID of pet that needs to be updated
  required: true
  schema:
    type: string
requestBody:
  content:
    'application/x-www-form-urlencoded':
      schema:
       properties:
          name:
            description: Updated name of the pet
            type: string
          status:
            description: Updated status of the pet
            type: string
       required:
         - status
responses:
  '200':
    description: Pet updated.
    content:
      'application/json': {}
      'application/xml': {}
  '405':
    description: Invalid input
    content:
      'application/json': {}
      'application/xml': {}
security:
- petstore_auth:
  - write:pets
  - read:pets
```


#### <a name="externalDocumentationObject"></a>External Documentation 對象

允許引用外部資源來擴展文檔。

##### 固定字段

字段名 | 類型 | 描述
---|:---:|---
<a name="externalDocDescription"></a>description | `string` | 對引用的外部文檔的簡短描述。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="externalDocUrl"></a>url | `string` | **必選**. 外部文檔的URL地址，這個值必須是URL地址格式。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### External Documentation 對象示例

```json
{
  "description": "Find more info here",
  "url": "https://example.com"
}
```

```yaml
description: Find more info here
url: https://example.com
```

#### <a name="parameterObject"></a>Parameter Object

描述一個操作參數。

一個參數的唯一性由 [name](#parameterName) 和 [location](#parameterIn) 的組合來確定。

##### 參數位置
有4種可能的參數位置值可用於`in`字段：
* path - 與 [Path Templating](#pathTemplating) 一起使用，當參數的值是URL操作路徑的一部分時可以使用，但是不包含主機地址或基礎路徑。比如在路徑  `/items/{itemId}` 中，路徑參數是 `itemId`。
* query - 追加在URL地址之後的參數，比如 `/items?id=###` 中，查詢參數是 `id`。
* header - 請求中使用的自定義請求頭，注意在 [RFC7230](https://tools.ietf.org/html/rfc7230#page-22) 中規定，請求頭的命名是不區分大小寫的。
* cookie - 用於傳遞特定的cookie值。


##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="parameterName"></a>name | `string` | **必選**. 參數的名稱。參數名是*區分大小寫*。<ul><li>如果 [`in`](#parameterIn) 的值是 `"path"`，那麼 `name` 字段的值必須與其關聯的 [Paths 對象](#pathsObject) 內 [path](#pathsPath) 字段的定義相呼應，查看 [Path Templating](#pathTemplating) 瞭解更多信息。<li>如果 [`in`](#parameterIn) 的值是 `"header"` 而且`name`字段的值是`"Accept"`, `"Content-Type"`或 `"Authorization"`之一，那麼此參數定義應該被忽略。<li>除此之外的情況，`name`表示 [`in`](#parameterIn) 屬性的名字.</ul>
<a name="parameterIn"></a>in | `string` | **必選**. 參數的位置，可能的值有 "query", "header", "path" 或 "cookie"。
<a name="parameterDescription"></a>description | `string` | 對此參數的簡要描述，這裡可以包含使用示例。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="parameterRequired"></a>required | `boolean` | 標明此參數是否是必選參數。如果 [參數位置](#parameterIn) 的值是 `path`，那麼這個參數一定是 **必選** 的因此這裡的值必須是`true`。其他的則視情況而定。此字段的默認值是`false`。
<a name="parameterDeprecated"></a> deprecated | `boolean` | 標明一個參數是被棄用的而且應該儘快移除對它的使用。
<a name="parameterAllowEmptyValue"></a> allowEmptyValue | `boolean` | 設置是否允許傳遞空參數，這隻在參數值為`query`時有效，默認值是`false`。如果同時指定了[`style`](#parameterStyle)屬性且值為`n/a`（無法被序列化）,那麼此字段 `allowEmptyValue`應該被忽略。

序列化參數的規則有兩種。
對於簡單的場景， [`schema`](#parameterSchema) 和 [`style`](#parameterStyle) 可以用於描述參數的結構和語法。

字段名 | 類型 | 描述
---|:---:|---
<a name="parameterStyle"></a>style | `string` | 描述根據參數值類型的不同如何序列化參數。默認值為（基於`in`字段的值）：`query` 對應 `form`；`path` 對應 `simple`; `header` 對應 `simple`; `cookie` 對應 `form`。
<a name="parameterExplode"></a>explode | `boolean` | 當這個值為`true`時，參數值類型為`array`或`object`的參數使用數組內的值或對象的鍵值對生成帶分隔符的參數值。對於其他類型的參數，這個字段沒有任何影響。當 [`style`](#parameterStyle) 是 `form`時，這裡的默認值是 `true`，對於其他 style 值類型，默認值是`false`。
<a name="parameterAllowReserved"></a>allowReserved | `boolean` | 決定此參數的值是否允許不使用%號編碼使用定義於 [RFC3986](https://tools.ietf.org/html/rfc3986#section-2.2)內的保留字符 `:/?#[]@!$&'()*+,;=`。 這個屬性僅用於`in`的值是`query`時，此字段的默認值是`false`。
<a name="parameterSchema"></a>schema | [Schema 對象](#schemaObject) \| [Reference 對象](#referenceObject) | 定於適用於此參數的類型綱要。
<a name="parameterExample"></a>example | Any | 不同媒體類型的示例，示例應該符合響應的綱要的編碼屬性。各個`example`之間應該是獨立的，而且如果一個引用的`schema`也包含一個示例，那麼這裡定義的示例應該 *覆蓋* `schema`包含的示例。為了展現無法被恰當的用 JSON 或 YAML 格式展現的示例時，可以使用經過必要的編碼的字符串值。
<a name="parameterExamples"></a>examples | Map[ `string`, [Example 對象](#exampleObject) \| [Reference 對象](#referenceObject)] | 不同媒體類型的示例。每個示例應該包含一個對應於指定編碼格式的格式正確的值，這個`examples`映射內包含的對象應該不同於`example`內的值。而且如果一個引用的`schema`也包含一個示例，那麼這裡定義的示例應該 *覆蓋* `schema`包含的示例。

對於更復雜的場景，[`content`](#parameterContent)屬性可以定義參數的媒體類型和概要。一個參數必須且只能包含`schema`和`content`屬性中的一個。當`example` 或`examples`字段提供了`schema`對象時，示例必須遵照參數的序列化策略。


字段名 | 類型 | 描述
---|:---:|---
<a name="parameterContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | 一個定義參數如何呈現的鍵值對映射。鍵是媒體類型，值是對應媒體類型的示例數據，此鍵值對只能包含一組鍵值對。

##### 樣式值

已經定義好了一組`style`類型用於支持常見的通用的簡單參數序列化。

`樣式` | [`類型`](#dataTypes) |  `in` | 描述
----------- | ------ | -------- | --------
matrix |  `primitive`, `array`, `object` |  `path` | Path 樣式的參數，參見 [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.7)
label | `primitive`, `array`, `object` |  `path` | Label 樣式的參數，參見 [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.5)
form |  `primitive`, `array`, `object` |  `query`, `cookie` | Form 樣式的參數，參見 [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.8). 此選項替換定義於OpenAPI 2.0中`collectionFormat`等於`csv` (當 `explode`值為 false)或`multi` (當 `explode`值為 true)的情況。
simple | `array` | `path`, `header` | Simple 樣式的參數，參見 [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.2). 此選項替換定義於OpenAPI 2.0 中 `collectionFormat`等於`csv`的情況。
spaceDelimited | `array` | `query` | 空格分隔的數組值。此選項替換定義於OpenAPI 2.0 中 `collectionFormat` equal to `ssv`的情況。
pipeDelimited | `array` | `query` | 管道符`|`的數組值。 此選項替換定義於OpenAPI 2.0 中 `collectionFormat` equal to `pipes`的情況。
deepObject | `object` | `query` | 提供一種簡單的方法來表示參數中的嵌套對象值.


##### Style 示例

建設一個參數名為`color`包含如下之一的值：

```
   string -> "blue"
   array -> ["blue","black","brown"]
   object -> { "R": 100, "G": 200, "B": 150 }
```

下面這個表展示了各個不同類型值之間的例子。

[`style`](#dataTypeFormat) | `explode` | `empty` | `string` | `array` | `object`
----------- | ------ | -------- | -------- | --------|-------
matrix | false | ;color | ;color=blue | ;color=blue,black,brown | ;color=R,100,G,200,B,150
matrix | true | ;color | ;color=blue | ;color=blue;color=black;color=brown | ;R=100;G=200;B=150
label | false | .  | .blue |  .blue.black.brown | .R.100.G.200.B.150
label | true | . | .blue |  .blue.black.brown | .R=100.G=200.B=150
form | false | color= | color=blue | color=blue,black,brown | color=R,100,G,200,B,150
form | true | color= | color=blue | color=blue&color=black&color=brown | R=100&G=200&B=150
simple | false | n/a | blue | blue,black,brown | R,100,G,200,B,150
simple | true | n/a | blue | blue,black,brown | R=100,G=200,B=150
spaceDelimited | false | n/a | n/a | blue%20black%20brown | R%20100%20G%20200%20B%20150
pipeDelimited | false | n/a | n/a | blue\|black\|brown | R\|100\|G\|200|G\|150
deepObject | true | n/a | n/a | n/a | color[R]=100&color[G]=200&color[B]=150

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Parameter 對象示例

一個值數組，數組元素為64位整數值的請求頭參數：

```json
{
  "name": "token",
  "in": "header",
  "description": "token to be passed as a header",
  "required": true,
  "schema": {
    "type": "array",
    "items": {
      "type": "integer",
      "format": "int64"
    }
  },
  "style": "simple"
}
```

```yaml
name: token
in: header
description: token to be passed as a header
required: true
schema:
  type: array
  items:
    type: integer
    format: int64
style: simple
```

一個值類型為字符串的路徑參數：
```json
{
  "name": "username",
  "in": "path",
  "description": "username to fetch",
  "required": true,
  "schema": {
    "type": "string"
  }
}
```

```yaml
name: username
in: path
description: username to fetch
required: true
schema:
  type: string
```

一個值類型為字符串的可選查詢參數，允許通過通過重複參數來傳遞多個值：
```json
{
  "name": "id",
  "in": "query",
  "description": "ID of the object to fetch",
  "required": false,
  "schema": {
    "type": "array",
    "items": {
      "type": "string"
    }
  },
  "style": "form",
  "explode": true
}
```

```yaml
name: id
in: query
description: ID of the object to fetch
required: false
schema:
  type: array
  items:
    type: string
style: form
explode: true
```

一個任意格式的查詢參數，允許使用指定類型的未定義參數：
```json
{
  "in": "query",
  "name": "freeForm",
  "schema": {
    "type": "object",
    "additionalProperties": {
      "type": "integer"
    },
  },
  "style": "form"
}
```

```yaml
in: query
name: freeForm
schema:
  type: object
  additionalProperties:
    type: integer
style: form
```

使用`content`定義序列化方法的複雜參數：

```json
{
  "in": "query",
  "name": "coordinates",
  "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "required": [
          "lat",
          "long"
        ],
        "properties": {
          "lat": {
            "type": "number"
          },
          "long": {
            "type": "number"
          }
        }
      }
    }
  }
}
```

```yaml
in: query
name: coordinates
content:
  application/json:
    schema:
      type: object
      required:
        - lat
        - long
      properties:
        lat:
          type: number
        long:
          type: number
```

#### <a name="requestBodyObject"></a>Request Body Object

定義請求體。

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="requestBodyDescription"></a>description | `string` | 對請求體的簡要描述，可以包含使用示例，[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="requestBodyContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | **必選**. 請求體的內容。請求體的屬性key是一個媒體類型或者[媒體類型範圍](https://tools.ietf.org/html/rfc7231#appendix-D)，值是對應媒體類型的示例數據。對於能匹配多個key的請求，定義更明確的請求會更優先被匹配。比如`text/plain`會覆蓋`text/*`的定義。
<a name="requestBodyRequired"></a>required | `boolean` | 指定請求體是不是應該被包含在請求中，默認值是`false`。


這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Request Body 示例

一個引用了模型定義的請求體。
```json
{
  "description": "user to add to the system",
  "content": {
    "application/json": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "User Example",
            "externalValue": "http://foo.bar/examples/user-example.json"
          }
        }
    },
    "application/xml": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "User example in XML",
            "externalValue": "http://foo.bar/examples/user-example.xml"
          }
        }
    },
    "text/plain": {
      "examples": {
        "user" : {
            "summary": "User example in Plain text",
            "externalValue": "http://foo.bar/examples/user-example.txt"
        }
      }
    },
    "*/*": {
      "examples": {
        "user" : {
            "summary": "User example in other format",
            "externalValue": "http://foo.bar/examples/user-example.whatever"
        }
      }
    }
  }
}
```

```yaml
description: user to add to the system
content:
  'application/json':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: User Example
        externalValue: 'http://foo.bar/examples/user-example.json'
  'application/xml':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: User Example in XML
        externalValue: 'http://foo.bar/examples/user-example.xml'
  'text/plain':
    examples:
      user:
        summary: User example in text plain format
        externalValue: 'http://foo.bar/examples/user-example.txt'
  '*/*':
    examples:
      user:
        summary: User example in other format
        externalValue: 'http://foo.bar/examples/user-example.whatever'
```

請求體是一個字符串的數組：
```json
{
  "description": "user to add to the system",
  "content": {
    "text/plain": {
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    }
  }
}
```

```yaml
description: user to add to the system
required: true
content:
  text/plain:
    schema:
      type: array
      items:
        type: string
```


#### <a name="mediaTypeObject"></a>Media Type 對象
每種媒體類型對象都有相應的綱要和示例來描述它。

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="mediaTypeSchema"></a>schema | [Schema 對象](#schemaObject) \| [Reference 對象](#referenceObject) | 定義此媒體類型的綱要。
<a name="mediaTypeExample"></a>example | Any | 媒體類型的示例。示例對象應該符合此媒體類型的格式， 這裡指定的`example`對象 object is mutually exclusive of the `examples` object.  而且如果引用的`schema`也包含示例，在這裡指定的`example`值將會覆蓋`schema`提供的示例。
<a name="mediaTypeExamples"></a>examples | Map[ `string`, [Example 對象](#exampleObject) \| [Reference 對象](#referenceObject)] | 媒體類型的示例，每個媒體對象的值都應該匹配它對應的媒體類型的格式。  The `examples` object is mutually exclusive of the `example` object.  而且如果引用的`schema`也包含示例，在這裡指定的`example`值將會覆蓋`schema`提供的示例。
<a name="mediaTypeEncoding"></a>encoding | Map[`string`, [Encoding 對象](#encodingObject)] | 屬性名與編碼信息的映射。每個屬性名必須存在於`schema`屬性的key中，當媒體類型等於`multipart`或`application/x-www-form-urlencoded`時，編碼對象信息僅適用於`requestBody`。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Media Type 示例

```js
{
  "application/json": {
    "schema": {
         "$ref": "#/components/schemas/Pet"
    },
    "examples": {
      "cat" : {
        "summary": "An example of a cat",
        "value":
          {
            "name": "Fluffy",
            "petType": "Cat",
            "color": "White",
            "gender": "male",
            "breed": "Persian"
          }
      },
      "dog": {
        "summary": "An example of a dog with a cat's name",
        "value" :  {
          "name": "Puma",
          "petType": "Dog",
          "color": "Black",
          "gender": "Female",
          "breed": "Mixed"
        },
      "frog": {
          "$ref": "#/components/examples/frog-example"
        }
      }
    }
  }
}
```

```yaml
application/json:
  schema:
    $ref: "#/components/schemas/Pet"
  examples:
    cat:
      summary: An example of a cat
      value:
        name: Fluffy
        petType: Cat
        color: White
        gender: male
        breed: Persian
    dog:
      summary: An example of a dog with a cat's name
      value:
        name: Puma
        petType: Dog
        color: Black
        gender: Female
        breed: Mixed
    frog:
      $ref: "#/components/examples/frog-example"
```

##### 對文件上傳的考慮

相對於2.0的規範，`file`內容的上傳與下載在開放API規範與其他類型一樣使用相同的語法來描述。
特別的是:

```yaml
# content transferred with base64 encoding
schema:
  type: string
  format: base64
```

```yaml
# content transferred in binary (octet-stream):
schema:
  type: string
  format: binary
```

這些示例同時適用於文件上傳和下載。

一個使用`POST`操作提交文件的`requestBody`看起來像下面這樣：

```yaml
requestBody:
  content:
    application/octet-stream:
      # any media type is accepted, functionally equivalent to `*/*`
      schema:
        # a binary file of any type
        type: string
        format: binary
```

此外，可以指定明確的媒體類型：

```yaml
# multiple, specific media types may be specified:
requestBody:
  content:
      # a binary file of type png or jpeg
    'image/jpeg':
      schema:
        type: string
        format: binary
    'image/png':
      schema:
        type: string
        format: binary
```

為了同時上傳多個文件，必須指定`multipart`媒體類型：

```yaml
requestBody:
  content:
    multipart/form-data:
      schema:
        properties:
          # The property name 'file' will be used for all files.
          file:
            type: array
            items:
              type: string
              format: binary

```

##### x-www-form-urlencoded 請求體的支持

可以使用下面定義的格式來提交form url編碼[RFC1866](https://tools.ietf.org/html/rfc1866)的內容：

```yaml
requestBody:
  content:
    application/x-www-form-urlencoded:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # complex types are stringified to support RFC 1866
            type: object
            properties: {}
```

在這個示例中，在內容被傳送到服務器之前，`requestBody`中的內容必須使用[RFC1866](https://tools.ietf.org/html/rfc1866/)中定義的方式字符串化。此外`address`字段的複雜對象將會被字符串化。

當使用`application/x-www-form-urlencoded`格式傳送複雜對象時，默認的序列化策略在[`Encoding Object`](#encodingObject)的[`style`](#encodingStyle) 屬性中定義為`form`.

##### 對`multipart`內容的特別思考

使用`multipart/form-data`作為`Content-Type`來傳送請求體是很常見的做法。相對於2.0版本的規範，當定義`multipart`內容的輸入參數時必須指定`schema`屬性。這不但支持複雜的結構而且支持多文件上傳機制。

當使用`multipart`類型是，可以使用boundaries來分隔傳送的內容，因此`multipart`定義了以下默認的`Content-Type`：

* 如果屬性是一個原始值或者是一個原始值的數組，那麼默認的Content-Type是 `text/plain`
* 如果屬性是複雜對象或者複雜對象的數組，那麼默認的Content-Type是`application/json`
* 如果屬性是`type: string`與`format: binary`或`format: base64`(也就是文件對象)的組合，那麼默認的Content-Type是 `application/octet-stream`


示例:

```yaml
requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # default Content-Type for objects is `application/json`
            type: object
            properties: {}
          profileImage:
            # default Content-Type for string/binary is `application/octet-stream`
            type: string
            format: binary
          children:
            # default Content-Type for arrays is based on the `inner` type (text/plain here)
            type: array
            items:
              type: string
          addresses:
            # default Content-Type for arrays is based on the `inner` type (object shown, so `application/json` in this example)
            type: array
            items:
              type: '#/components/schemas/Address'
```

這裡介紹一下用來控制序列化`multipart`請求體的`encoding`屬性，這個屬性只適用於`multipart`和`application/x-www-form-urlencoded`類型的請求體。

#### <a name="encodingObject"></a>Encoding 對象

一個編碼定義僅適用於一個綱要屬性。

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="encodingContentType"></a>contentType | `string` | 對具體屬性的 Content-Type的編碼。默認值取決於屬性的類型：`application/octet-stream`編碼適用於`binary`格式的`string`；`text/plain`適用於其他原始值；`application/json`適用於`object`；對於`array`值類型的默認值取決於數組內元素的類型，默認值可以是明確的媒體類型(比如`application/json`), 或者通配符類型的媒體類型(比如`image/*`), 又或者是用分號分隔的兩種媒體類型。
<a name="encodingHeaders"></a>headers | Map[`string`, [Header 對象](#headerObject) \| [Reference 對象](#referenceObject)] | 提供附加信息的請求頭鍵值對映射。比如`Content-Disposition`、`Content-Type`各自描述了不同的信息而且在這裡將會被忽略，如果請求體的媒體類型不是`multipart`，這個屬性將會被忽略。
<a name="encodingStyle"></a>style | `string` | 描述一個屬性根據它的類型將會被如何序列化。查看[Parameter 對象](#parameterObject)的[`style`](#parameterStyle)屬性可以得到更多詳細信息。這個屬性的行為與`query`參數相同，包括默認值的定義。如果請求體的媒體類型不是`application/x-www-form-urlencoded`，這個屬性將會被忽略。
<a name="encodingExplode"></a>explode | `boolean` | 當這個值為true時，類型為`array`或`object`的屬性值會為數組的每個元素或對象的每個鍵值對分開生成參數。這個屬性對其他數據類型沒有影響。當[`style`](#encodingStyle)為`form`時，這個屬性的默認值是`true`，對於其他的`style`類型，這個屬性的默認值是`false`。這個屬性會被忽略如果請求體的媒體類型不是`application/x-www-form-urlencoded`。
<a name="encodingAllowReserved"></a>allowReserved | `boolean` | 決定此參數的值是否允許不使用%號編碼使用定義於 [RFC3986](https://tools.ietf.org/html/rfc3986#section-2.2)內的保留字符 `:/?#[]@!$&'()*+,;=`。 這個屬性僅用於`in`的值是`query`時，此字段的默認值是`false`。 這個屬性會被忽略如果請求體的媒體類型不是`application/x-www-form-urlencoded`。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Encoding 對象示例

```yaml
requestBody:
  content:
    multipart/mixed:
      schema:
        type: object
        properties:
          id:
            # default is text/plain
            type: string
            format: uuid
          address:
            # default is application/json
            type: object
            properties: {}
          historyMetadata:
            # need to declare XML format!
            description: metadata in XML format
            type: object
            properties: {}
          profileImage:
            # default is application/octet-stream, need to declare an image type only!
            type: string
            format: binary
      encoding:
        historyMetadata:
          # require XML Content-Type in utf-8 encoding
          contentType: application/xml; charset=utf-8
        profileImage:
          # only accept png/jpeg
          contentType: image/png, image/jpeg
          headers:
            X-Rate-Limit-Limit:
              description: The number of allowed requests in the current period
              schema:
                type: integer
```

#### <a name="responsesObject"></a>Responses 對象

描述一個操作可能發生的響應的響應碼與響應包含的響應體的對象。

一份API文檔不必包含所有可能響應碼，因為有些狀態碼無法提前預知。儘管如此，一份文檔還是應當包含所有成功的響應和任何已知的錯誤響應。

`default`字段可以用來標記一個響應適用於其他未被規範明確定義的HTTP響應碼的默認響應。

一個`Responses 對象`必須至少包含一個響應碼，而且是成功的響應。

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="responsesDefault"></a>default | [Response 對象](#responseObject) \| [Reference 對象](#referenceObject) | 用於描述未被明確聲明的HTTP響應碼的響應的文檔。使用這個字段來覆蓋未聲明的響應。一個 [Reference 對象](#referenceObject) 可以鏈接定義於 [OpenAPI 對象 components/responses](#componentsResponses) 區域的響應對象。

##### 模式字段
字段名模式 | 類型 | 描述
---|:---:|---
<a name="responsesCode"></a>[HTTP Status Code](#httpCodes) | [Response 對象](#responseObject) \| [Reference 對象](#referenceObject) | 任何 [HTTP status code](#httpCodes) 都可以被用作屬性名， 但是每一個狀態碼只能使用一次，用於描述此狀態碼的響應。一個 [Reference 對象](#referenceObject) 可以鏈接定義於 [OpenAPI 對象 components/responses](#componentsResponses) 區域的響應對象。這個字段名必須包含在雙引號中 (例如 "200") 以兼容 JSON 和 YAML。這個字段可以包含大寫的通配字符`X`來定義響應碼的範圍。例如，`2XX` 代表所有位於 `[200-299]` 範圍內的響應碼。只允許使用以下範圍定義：`1XX`, `2XX`, `3XX`, `4XX`, 和 `5XX`。如果同時包含範圍定義與明確定義的響應，那麼明確定義的響應有更高的優先級。


這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Responses 對象示例

一個代表成功操作的 200 響應和一個代表其他操作狀態的默認響應（暗示是一個錯誤）：

```json
{
  "200": {
    "description": "a pet to be returned",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/Pet"
        }
      }
    }
  },
  "default": {
    "description": "Unexpected error",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/ErrorModel"
        }
      }
    }
  }
}
```

```yaml
'200':
  description: a pet to be returned
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/Pet'
default:
  description: Unexpected error
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/ErrorModel'
```

#### <a name="responseObject"></a>Response對象
描述單個API操作的響應，包括設計時間、基於不同響應也包括到相應操作的靜態`links`

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="responseDescription"></a>description | `string` | **必選**. 對響應的簡短描述。[CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="responseHeaders"></a>headers | Map[`string`, [Header Object](#headerObject)  \| [Reference Object](#referenceObject)] |  映射HTTP頭名稱到其定義。[RFC7230](https://tools.ietf.org/html/rfc7230#page-22) 規定了HTTP頭名稱不區分大小寫。如果一個響應頭使用`"Content-Type"`作為HTTP頭名稱，它會被忽略。
<a name="responseContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | 一個包含描述預期響應負載的映射。使用 media type 或 [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) 作為鍵，以響應的描述作為值。當一個響應匹配多個鍵時，只有最明確的鍵才適用。比如：text/plain 會覆蓋 text/*
<a name="responseLinks"></a>links | Map[`string`, [Link Object](#linkObject) \| [Reference Object](#referenceObject)] | A map of operations links that can be followed from the response. The key of the map is a short name for the link, following the naming constraints of the names for [Component Objects](#componentsObject).

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Response 對象示例s

一個包含複雜類型的數組格式的響應：

```json
{
  "description": "A complex object array response",
  "content": {
    "application/json": {
      "schema": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/VeryComplexType"
        }
      }
    }
  }
}
```

```yaml
description: A complex object array response
content:
  application/json:
    schema:
      type: array
      items:
        $ref: '#/components/schemas/VeryComplexType'
```

字符串類型的響應：

```json
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  }

}
```

```yaml
description: A simple string response
representations:
  text/plain:
    schema:
      type: string
```

帶HTTP頭的普通文本類型的響應：

```json
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  },
  "headers": {
    "X-Rate-Limit-Limit": {
      "description": "The number of allowed requests in the current period",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Remaining": {
      "description": "The number of remaining requests in the current period",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Reset": {
      "description": "The number of seconds left in the current period",
      "schema": {
        "type": "integer"
      }
    }
  }
}
```

```yaml
description: A simple string response
content:
  text/plain:
    schema:
      type: string
    example: 'whoa!'
headers:
  X-Rate-Limit-Limit:
    description: The number of allowed requests in the current period
    schema:
      type: integer
  X-Rate-Limit-Remaining:
    description: The number of remaining requests in the current period
    schema:
      type: integer
  X-Rate-Limit-Reset:
    description: The number of seconds left in the current period
    schema:
      type: integer
```

沒有返回值的響應：

```json
{
  "description": "object created"
}
```

```yaml
description: object created
```

#### <a name="callbackObject"></a>Callback 對象

A map of possible out-of band callbacks related to the parent operation.
映射中的每個值都是一個描述一組可能會被API提供者發起的請求和相應的響應的 [Path Item Object](#pathItemObject) 。用以標識回調對象的鍵是一個表達式，表達式會在運行時被計算，得到的值作為回調操作的URL。

##### 模式字段
字段名模式 | 類型 | 描述
---|:---:|---
<a name="callbackExpression"></a>{expression} | [Path Item Object](#pathItemObject) | 一個用於定義回調請求和響應的 Path Item Object。 A [complete example](../examples/v3.0/callback-example.yaml) is available.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Key Expression

用於標識 [Path Item Object](#pathItemObject) 的鍵是一個 [runtime expression](#runtimeExpression)，此表達式會在運行時的HTTP請求/響應上下文中被計算，計算結果用於表示回調請求的URL。
一個簡單的例子是 `$request.body#/url`。
However, using a [runtime expression](#runtimeExpression) the complete HTTP message can be accessed.
This includes accessing any part of a body that a JSON Pointer [RFC6901](https://tools.ietf.org/html/rfc6901) can reference.

For example, given the following HTTP request:

```http
POST /subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 187

{
  "failedUrl" : "http://clientdomain.com/failed",
  "successUrls" : [
    "http://clientdomain.com/fast",
    "http://clientdomain.com/medium",
    "http://clientdomain.com/slow"
  ]
}

201 Created
Location: http://example.org/subscription/1
```

The following examples show how the various expressions evaluate, assuming the callback operation has a path parameter named `eventType` and a query parameter named `queryUrl`.

Expression | Value
---|:---
$url | http://example.org/subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning
$method | POST
$request.path.eventType | myevent
$request.query.queryUrl | http://clientdomain.com/stillrunning
$request.header.content-Type | application/json
$request.body#/failedUrl | http://clientdomain.com/stillrunning
$request.body#/successUrls/2 | http://clientdomain.com/medium
$response.header.Location | http://example.org/subscription/1


##### Callback 對象示例

The following example shows a callback to the URL specified by the `id` and `email` property in the request body.

```yaml
myWebhook:
  'http://notificationServer.com?transactionId={$request.body#/id}&email={$request.body#/email}':
    post:
      requestBody:
        description: Callback payload
        content:
          'application/json':
            schema:
              $ref: '#/components/schemas/SomePayload'
      responses:
        '200':
          description: webhook successfully processed and no retries will be performed
```


#### <a name="exampleObject"></a>Example Object

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="exampleSummary"></a>summary | `string` | Short description for the example.
<a name="exampleDescription"></a>description | `string` | Long description for the example. [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="exampleValue"></a>value | Any | Embedded literal example. The `value` field and `externalValue` field are mutually exclusive. To represent examples of media types that cannot naturally represented in JSON or YAML, use a string value to contain the example, escaping where necessary.
<a name="exampleExternalValue"></a>externalValue | `string` | A URL that points to the literal example. This provides the capability to reference examples that cannot easily be included in JSON or YAML documents.  The `value` field and `externalValue` field are mutually exclusive.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

In all cases, the example value is expected to be compatible with the type schema
of its associated value.  Tooling implementations MAY choose to
validate compatibility automatically, and reject the example value(s) if incompatible.

##### Example 對象示例

```yaml
# in a model
schemas:
  properties:
    name:
      type: string
      examples:
        name:
          $ref: http://example.org/petapi-examples/openapi.json#/components/examples/name-example

# in a request body:
  requestBody:
    content:
      'application/json':
        schema:
          $ref: '#/components/schemas/Address'
        examples:
          foo:
            summary: A foo example
            value: {"foo": "bar"}
          bar:
            summary: A bar example
            value: {"bar": "baz"}
      'application/xml':
        examples:
          xmlExample:
            summary: This is an example in XML
            externalValue: 'http://example.org/examples/address-example.xml'
      'text/plain':
        examples:
          textExample:
            summary: This is a text example
            externalValue: 'http://foo.bar/examples/address-example.txt'


# in a parameter
  parameters:
    - name: 'zipCode'
      in: 'query'
      schema:
        type: 'string'
        format: 'zip-code'
        examples:
          zip-example:
            $ref: '#/components/examples/zip-example'

# in a response
  responses:
    '200':
      description: your car appointment has been booked
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SuccessResponse'
          examples:
            confirmation-success:
              $ref: '#/components/examples/confirmation-success'
```


#### <a name="linkObject"></a>Link Object

The `Link object` represents a possible design-time link for a response.
The presence of a link does not guarantee the caller's ability to successfully invoke it, rather it provides a known relationship and traversal mechanism between responses and other operations.

Unlike _dynamic_ links (i.e. links provided **in** the response payload), the OAS linking mechanism does not require link information in the runtime response.

For computing links, and providing instructions to execute them, a [runtime expression](#runtimeExpression) is used for accessing values in an operation and using them as parameters while invoking the linked operation.

##### 固定字段

字段名  |  Type  | 描述
---|:---:|---
<a name="linkOperationRef"></a>operationRef | `string` | A relative or absolute reference to an OAS operation. This field is mutually exclusive of the `operationId` field, and MUST point to an [Operation Object](#operationObject). Relative `operationRef` values MAY be used to locate an existing [Operation Object](#operationObject) in the OpenAPI definition.
<a name="linkOperationId"></a>operationId  | `string` | The name of an _existing_, resolvable OAS operation, as defined with a unique `operationId`.  This field is mutually exclusive of the `operationRef` field.
<a name="linkParameters"></a>parameters   | Map[`string`, Any \| [{expression}](#runtimeExpression)] | A map representing parameters to pass to an operation as specified with `operationId` or identified via `operationRef`. The key is the parameter name to be used, whereas the value can be a constant or an expression to be evaluated and passed to the linked operation.  The parameter name can be qualified using the [parameter location](#parameterIn) `[{in}.]{name}` for operations that use the same parameter name in different locations (e.g. path.id).
<a name="linkRequestBody"></a>requestBody | Any \| [{expression}](#runtimeExpression) | A literal value or [{expression}](#runtimeExpression) to use as a request body when calling the target operation.
<a name="linkDescription"></a>description  | `string` | A description of the link. [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="linkServer"></a>server       | [Server Object](#serverObject) | A server object to be used by the target operation.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

A linked operation MUST be identified using either an `operationRef` or `operationId`.
In the case of an `operationId`, it MUST be unique and resolved in the scope of the OAS document.
Because of the potential for name clashes, the `operationRef` syntax is preferred
for specifications with external references.

##### Examples

Computing a link from a request operation where the `$request.path.id` is used to pass a request parameter to the linked operation.

```yaml
paths:
  /users/{id}:
    parameters:
    - name: id
      in: path
      required: true
      description: the user identifier, as userId
      schema:
        type: string
    get:
      responses:
        '200':
          description: the user being returned
          content:
            application/json:
              schema:
                type: object
                properties:
                  uuid: # the unique user id
                    type: string
                    format: uuid
        links:
          address:
            # the target link operationId
            operationId: getUserAddress
            parameters:
              # get the `id` field from the request path parameter named `id`
              userId: $request.path.id
  # the path item of the linked operation
  /users/{userid}/address:
    parameters:
    - name: userid
      in: path
      required: true
      description: the user identifier, as userId
      schema:
        type: string
      # linked operation
      get:
        operationId: getUserAddress
        responses:
          '200':
            description: the user's address
```

When a runtime expression fails to evaluate, no parameter value is passed to the target operation.

Values from the response body can be used to drive a linked operation.

```yaml
links:
  address:
    operationId: getUserAddressByUUID
    parameters:
      # get the `id` field from the request path parameter named `id`
      userUuid: $response.body#/uuid
```

Clients follow all links at their discretion.
Neither permissions, nor the capability to make a successful call to that link, is guaranteed
solely by the existence of a relationship.


##### OperationRef Examples

As references to `operationId` MAY NOT be possible (the `operationId` is an optional
value), references MAY also be made through a relative `operationRef`:

```yaml
links:
  UserRepositories:
    # returns array of '#/components/schemas/repository'
    operationRef: '#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

or an absolute `operationRef`:

```yaml
links:
  UserRepositories:
    # returns array of '#/components/schemas/repository'
    operationRef: 'https://na2.gigantic-server.com/#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

Note that in the use of `operationRef`, the _escaped forward-slash_ is necessary when
using JSON references.


##### <a name="runtimeExpression"></a>Runtime Expressions

Runtime expressions allow defining values based on information that will only be available within the HTTP message in an actual API call.
This mechanism is used by [Link Objects](#linkObject) and [Callback Objects](#callbackObject).

The runtime expression is defined by the following [ABNF](https://tools.ietf.org/html/rfc5234) syntax

```
      expression = ( "$url" | "$method" | "$statusCode" | "$request." source | "$response." source )
      source = ( header-reference | query-reference | path-reference | body-reference )
      header-reference = "header." token
      query-reference = "query." name
      path-reference = "path." name
      body-reference = "body" ["#" fragment]
      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)
      name = *( char )
      char = as per RFC [7159](https://tools.ietf.org/html/rfc7159#section-7)
      token = as per RFC [7230](https://tools.ietf.org/html/rfc7230#section-3.2.6)
```

The `name` identifier is case-sensitive, whereas `token` is not.

The table below provides examples of runtime expressions and examples of their use in a value:

##### <a name="runtimeExpressionExamples"></a>Examples

Source Location | example expression  | notes
---|:---|:---|
HTTP Method            | `$method`         | The allowable values for the `$method` will be those for the HTTP operation.
Requested media type | `$request.header.accept`        |
Request parameter      | `$request.path.id`        | Request parameters MUST be declared in the `parameters` section of the parent operation or they cannot be evaluated. This includes request headers.
Request body property   | `$request.body#/user/uuid`   | In operations which accept payloads, references may be made to portions of the `requestBody` or the entire body.
Request URL            | `$url`            |
Response value         | `$response.body#/status`       |  In operations which return payloads, references may be made to portions of the response body or the entire body.
Response header        | `$response.header.Server` |  Single header values only are available

Runtime expressions preserve the type of the referenced value.
Expressions can be embedded into string values by surrounding the expression with `{}` curly braces.

#### <a name="headerObject"></a>Header Object

The Header Object follows the structure of the [Parameter Object](#parameterObject) with the following changes:

1. `name` MUST NOT be specified, it is given in the corresponding `headers` map.
2. `in` MUST NOT be specified, it is implicitly in `header`.
3. All traits that are affected by the location MUST be applicable to a location of `header` (for example, [`style`](#parameterStyle)).

##### Header 對象示例

A simple header of type `integer`:

```json
{
  "description": "The number of allowed requests in the current period",
  "schema": {
    "type": "integer"
  }
}
```

```yaml
description: The number of allowed requests in the current period
schema:
  type: integer
```

#### <a name="tagObject"></a>Tag Object

Adds metadata to a single tag that is used by the [Operation Object](#operationObject).
It is not mandatory to have a Tag Object per tag defined in the Operation Object instances.

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="tagName"></a>name | `string` | **必選**. The name of the tag.
<a name="tagDescription"></a>description | `string` | A short description for the tag. [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="tagExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | Additional external documentation for this tag.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Tag 對象示例

```json
{
	"name": "pet",
	"description": "Pets operations"
}
```

```yaml
name: pet
description: Pets operations
```

#### <a name="examplesObject"></a>Examples Object

In an `example`, a JSON Reference MAY be used, with the
explicit restriction that examples having a JSON format with object named
`$ref` are not allowed. Therefore, that `example`, structurally, can be
either a string primitive or an object, similar to `additionalProperties`.

In all cases, the payload is expected to be compatible with the type schema
for the associated value.  Tooling implementations MAY choose to
validate compatibility automatically, and reject the example value(s) if they
are incompatible.

```yaml
# in a model
schemas:
  properties:
    name:
      type: string
      example:
        $ref: http://foo.bar#/examples/name-example

# in a request body, note the plural `examples`
  requestBody:
    content:
      'application/json':
        schema:
          $ref: '#/components/schemas/Address'
        examples:
          foo:
            value: {"foo": "bar"}
          bar:
            value: {"bar": "baz"}
      'application/xml':
        examples:
          xml:
            externalValue: 'http://foo.bar/examples/address-example.xml'
      'text/plain':
        examples:
          text:
            externalValue: 'http://foo.bar/examples/address-example.txt'

# in a parameter
  parameters:
    - name: 'zipCode'
      in: 'query'
      schema:
        type: 'string'
        format: 'zip-code'
        example:
          $ref: 'http://foo.bar#/examples/zip-example'

# in a response, note the singular `example`:
  responses:
    '200':
      description: your car appointment has been booked
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SuccessResponse'
          example:
            $ref: http://foo.bar#/examples/address-example.json
```

#### <a name="referenceObject"></a>Reference 對象

一個允許引用規範內部的其他部分或外部規範的對象。

Reference Object 定義於 [JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03) 且遵循相同的結構、行為和規則。

For this specification, reference resolution is accomplished as defined by the JSON Reference specification and not by the JSON Schema specification.

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="referenceRef"></a>$ref | `string` | **必選**. 引用字符串。

此對象不能被擴展，任何附加的屬性將會被忽略。

##### Reference 對象示例

```json
{
	"$ref": "#/components/schemas/Pet"
}
```

```yaml
$ref: '#/components/schemas/Pet'
```

##### 關聯外部文檔示例
```json
{
  "$ref": "Pet.json"
}
```

```yaml
$ref: Pet.yaml
```

##### 關聯外部文檔的一部分
```json
{
  "$ref": "definitions.json#/Pet"
}
```

```yaml
$ref: definitions.yaml#/Pet
```

#### <a name="schemaObject"></a>Schema Object

Schema Object 用於定義輸入和輸出的數據類型。這些類型可以是對象，但也可以是原始值和數組。這個對象是 [JSON Schema Specification Wright Draft 00](http://json-schema.org/) 擴展後的子集.

關於property的的更多信息請查看 [JSON Schema Core](https://tools.ietf.org/html/draft-wright-json-schema-00) 和 [JSON Schema Validation](https://tools.ietf.org/html/draft-wright-json-schema-validation-00)。除非另有說明，否則 properties 定義遵循JSON Schema。

##### Properties

以下 properties 是直接從 JSON Schema 提取出來的，而且遵循同樣的規範：

- title
- multipleOf
- maximum
- exclusiveMaximum
- minimum
- exclusiveMinimum
- maxLength
- minLength
- pattern (This string SHOULD be a valid regular expression, according to the [ECMA 262 regular expression](https://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5) dialect)
- maxItems
- minItems
- uniqueItems
- maxProperties
- minProperties
- required
- enum

以下 properties 是從 JSON Schema 提取出來的，但是做了一些調整以適應 OpenAPI Specification。
- type - 值必須是一個字符串，不支持以數組形式定義多個值。
- allOf - Inline 或 referenced 的 schema 必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema。
- oneOf - Inline 或 referenced 的 schema 必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema。
- anyOf - Inline 或 referenced 的 schema 必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema。
- not - Inline 或 referenced 的 schema 必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema。
- items - 值必須是一個對象且不是一個數組。Inline 或 referenced 的 schema 必須是一個 [Schema Object](#schemaObject)且不是一個標準的 JSON Schem。. `items` 必須存在如果 `type` 的值是 `array`。
- properties - Property 定義必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema (inline 或 referenced).
- additionalProperties - 值可以是 boolean 或 object. Inline 或 referenced schema 必須是一個 [Schema Object](#schemaObject) 且不是一個標準的 JSON Schema。
- description - [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
- format - 查看 [Data Type Formats](#dataTypeFormat) 以深入瞭解細節。在依靠 JSON Schema 定義的格式的同時，OAS 額外提供了一些預定義的格式。
- default - The default value represents what would be assumed by the consumer of the input as the value of the schema if one is not provided. 不同於 JSON Schema，這個值必須符合定義與相同級別的 Schema Object 中定義的類型，比如 `type` 是 `string`，那麼 `default` 可以是 `"foo"` 但不能是 `1`。

另外，任何可以使用 Schema Object 的地方也可以使用 [Reference Object](#referenceObject) 替代。這允許引用一個定義而避免重複定義。

未在此處提及的 JSON Schema 規範中定義的其他屬性將嚴格的不被支持。

Other than the JSON Schema subset fields, 以下字段可能會被用於後續的 schema documentation：

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="schemaNullable"></a>nullable | `boolean` | 對於定義的schema，允許發送 `null` 值。默認值是 `false`。
<a name="schemaDiscriminator"></a>discriminator | [Discriminator Object](#discriminatorObject) | Adds support for polymorphism. The discriminator is an object name that is used to differentiate between other schemas which may satisfy the payload description. See [Composition and Inheritance](#schemaComposition) for more details.
<a name="schemaReadOnly"></a>readOnly | `boolean` | 僅與 Schema `"properties"` 定義有關。 聲明此屬性是 "readonly" 的。這意味著它可以作為 response 的一部分但不應該作為 request 的一部分被髮送。如果一個 property 的 `readOnly` 被標記為 `true` 且在 `required` 列表中，`required` 將只作用於 response。一個 property 的 `readOnly` 和 `writeOnly` 不允許同時被標記為 `true`。默認值是 `false`。
<a name="schemaWriteOnly"></a>writeOnly | `boolean` | 僅與 Schema `"properties"` 定義有關。聲明此 property 為 "write only"。所以它可以作為 request 的一部分而不應該作為 response 的一部分被髮送。如果一個 property 的 `writeOnly` 被標記為 `true` 且在 `required` 列表中，`required` 將只作用於 request。一個 property 的 `readOnly` 和 `writeOnly` 不能同時被標記為 `true`。默認值是 `false`。
<a name="schemaXml"></a>xml | [XML Object](#xmlObject) | 這隻能用於 properties schemas，在 root schemas 中沒有效果。Adds additional metadata to describe the XML representation of this property.
<a name="schemaExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | 此 schema 附加的外部文檔。
<a name="schemaExample"></a>example | Any | 一個用於示範此 schema實例的示例，可以是任意格式。為了表達無法用 JSON 或 YAML 格式呈現的示例，可以使用 string 類型的值，且在必要的地方需要使用字符轉義。
<a name="schemaDeprecated"></a> deprecated | `boolean` | 表示一個 schema 是廢棄的，應該逐漸被放棄使用。默認值是 `false`.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

###### <a name="schemaComposition"></a>Composition and Inheritance (Polymorphism)

The OpenAPI Specification allows combining and extending model definitions using the `allOf` property of JSON Schema, in effect offering model composition.
`allOf` takes an array of object definitions that are validated *independently* but together compose a single object.

While composition offers model extensibility, it does not imply a hierarchy between the models.
To support polymorphism, the OpenAPI Specification adds the `discriminator` field.
When used, the `discriminator` will be the name of the property that decides which schema definition validates the structure of the model.
As such, the `discriminator` field MUST be a required field.
There are are two ways to define the value of a discriminator for an inheriting instance.
- Use the schema name.
- Override the schema name by overriding the property with a new value. If a new value exists, this takes precedence over the schema name.
As such, inline schema definitions, which do not have a given id, *cannot* be used in polymorphism.

###### XML Modeling

The [xml](#schemaXml) property allows extra definitions when translating the JSON definition to XML.
The [XML Object](#xmlObject) contains additional information about the available options.

##### Schema 對象示例s

###### Primitive Sample

```json
{
  "type": "string",
  "format": "email"
}
```

```yaml
type: string
format: email
```

###### Simple Model

```json
{
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "type": "string"
    },
    "address": {
      "$ref": "#/components/schemas/Address"
    },
    "age": {
      "type": "integer",
      "format": "int32",
      "minimum": 0
    }
  }
}
```

```yaml
type: object
required:
- name
properties:
  name:
    type: string
  address:
    $ref: '#/components/schemas/Address'
  age:
    type: integer
    format: int32
    minimum: 0
```

###### Model with Map/Dictionary Properties

For a simple string to string mapping:

```json
{
  "type": "object",
  "additionalProperties": {
    "type": "string"
  }
}
```

```yaml
type: object
additionalProperties:
  type: string
```

For a string to model mapping:

```json
{
  "type": "object",
  "additionalProperties": {
    "$ref": "#/components/schemas/ComplexModel"
  }
}
```

```yaml
type: object
additionalProperties:
  $ref: '#/components/schemas/ComplexModel'
```

###### Model with Example

```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "name"
  ],
  "example": {
    "name": "Puma",
    "id": 1
  }
}
```

```yaml
type: object
properties:
  id:
    type: integer
    format: int64
  name:
    type: string
required:
- name
example:
  name: Puma
  id: 1
```

###### Models with Composition

```json
{
  "components": {
    "schemas": {
      "ErrorModel": {
        "type": "object",
        "required": [
          "message",
          "code"
        ],
        "properties": {
          "message": {
            "type": "string"
          },
          "code": {
            "type": "integer",
            "minimum": 100,
            "maximum": 600
          }
        }
      },
      "ExtendedErrorModel": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorModel"
          },
          {
            "type": "object",
            "required": [
              "rootCause"
            ],
            "properties": {
              "rootCause": {
                "type": "string"
              }
            }
          }
        ]
      }
    }
  }
}
```

```yaml
components:
  schemas:
    ErrorModel:
      type: object
      required:
      - message
      - code
      properties:
        message:
          type: string
        code:
          type: integer
          minimum: 100
          maximum: 600
    ExtendedErrorModel:
      allOf:
      - $ref: '#/components/schemas/ErrorModel'
      - type: object
        required:
        - rootCause
        properties:
          rootCause:
            type: string
```

###### Models with Polymorphism Support

```json
{
  "components": {
    "schemas": {
      "Pet": {
        "type": "object",
        "discriminator": {
          "propertyName": "petType"
        },
        "properties": {
          "name": {
            "type": "string"
          },
          "petType": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "petType"
        ]
      },
      "Cat": {
        "description": "A representation of a cat. Note that `Cat` will be used as the discriminator value.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "huntingSkill": {
                "type": "string",
                "description": "The measured skill for hunting",
                "default": "lazy",
                "enum": [
                  "clueless",
                  "lazy",
                  "adventurous",
                  "aggressive"
                ]
              }
            },
            "required": [
              "huntingSkill"
            ]
          }
        ]
      },
      "Dog": {
        "description": "A representation of a dog. Note that `Dog` will be used as the discriminator value.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "packSize": {
                "type": "integer",
                "format": "int32",
                "description": "the size of the pack the dog is from",
                "default": 0,
                "minimum": 0
              }
            },
            "required": [
              "packSize"
            ]
          }
        ]
      }
    }
  }
}
```

```yaml
components:
  schemas:
    Pet:
      type: object
      discriminator:
        propertyName: petType
      properties:
        name:
          type: string
        petType:
          type: string
      required:
      - name
      - petType
    Cat:  ## "Cat" will be used as the discriminator value
      description: A representation of a cat
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          huntingSkill:
            type: string
            description: The measured skill for hunting
            enum:
            - clueless
            - lazy
            - adventurous
            - aggressive
        required:
        - huntingSkill
    Dog:  ## "Dog" will be used as the discriminator value
      description: A representation of a dog
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          packSize:
            type: integer
            format: int32
            description: the size of the pack the dog is from
            default: 0
            minimum: 0
        required:
        - packSize
```

#### <a name="discriminatorObject"></a>Discriminator 對象

當一個 request bodies 或 response payloads 可以是多種 schemas 時，可以使用一個 `discriminator` 對象來幫助序列化、反序列化和校驗。  The discriminator is a specific object in a schema which is used to inform the consumer of the specification of an alternative schema based on the value associated with it.

當使用 discriminator 時，_inline_ schemas 不會被考慮。

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="propertyName"></a>propertyName | `string` | **必選**. 在 payload 中表示 discriminator 值的屬性的名稱。
<a name="discriminatorMapping"></a> mapping | Map[`string`, `string`] | 一個映射 payload 中的值和 schema 名稱或引用的對象。

discriminator 屬性僅在與 `oneOf`, `anyOf`, `allOf` 這幾個複合關鍵字之一一起使用時才合法.

在 OAS 3.0 中，一個 response payload 僅可以使用一種類型來描述：

```
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
```

也就是說 payload _必須_ 且只能滿足 `Cat`、`Dog` 或 `Lizzard` schemas 中的一個。 In this case, a discriminator MAY act as a "hint" to shortcut validation and selection of the matching schema which may be a costly operation, depending on the complexity of the schema. We can then describe exactly which field tells us which schema to use:


```
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
  discriminator:
    propertyName: pet_type
```

The expectation now is that a property with name `pet_type` _MUST_ be present in the response payload, and the value will correspond to the name of a schema defined in the OAS document.  Thus the response payload:

```
{
  "id": 12345,
  "pet_type": "Cat"
}
```

Will indicate that the `Cat` schema be used in conjunction with this payload.

In scenarios where the value of the discriminator field does not match the schema name or implicit mapping is not possible, an optional `mapping` definition MAY be used:

```
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
  - $ref: 'https://gigantic-server.com/schemas/Monster/schema.json'
  discriminator:
    propertyName: pet_type
    mapping:
      dog: '#/components/schemas/Dog'
      monster: 'https://gigantic-server.com/schemas/Monster/schema.json'
```

Here the discriminator _value_ of `dog` will map to the schema `#/components/schemas/Dog`, rather than the default (implicit) value of `Dog`.  If the discriminator _value_ does not match an implicit or explicit mapping, no schema can be determined and validation SHOULD fail. Mapping keys MUST be string values, but tooling MAY convert response values to strings for comparison.

When used in conjunction with the `anyOf` construct, the use of the discriminator can avoid ambiguity where multiple schemas may satisfy a single payload.

In both the `oneOf` and `anyOf` use cases, all possible schemas MUST be listed explicitly.  To avoid redundancy, the discriminator MAY be added to a parent schema definition, and all schemas comprising the parent schema in an `allOf` construct may be used as an alternate schema.

For example:

```
components:
  schemas:
    Pet:
      type: object
      required:
      - pet_type
      properties:
        pet_type:
          type: string
      discriminator:
        propertyName: pet_type
        mapping:
          cachorro: Dog
    Cat:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # all other properties specific to a `Cat`
        properties:
          name:
            type: string
    Dog:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # all other properties specific to a `Dog`
        properties:
          bark:
            type: string
    Lizard:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # all other properties specific to a `Lizard`
        properties:
          lovesRocks:
            type: boolean
```

a payload like this:

```
{
  "pet_type": "Cat",
  "name": "misty"
}
```

will indicate that the `Cat` schema be used.  Likewise this schema:

```
{
  "pet_type": "cachorro",
  "bark": "soft"
}
```

will map to `Dog` because of the definition in the `mappings` element.


#### <a name="xmlObject"></a>XML Object

A metadata object that allows for more fine-tuned XML model definitions.

When using arrays, XML element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be used to add that information.
See examples for expected behavior.

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="xmlName"></a>name | `string` | Replaces the name of the element/attribute used for the described schema property. When defined within `items`, it will affect the name of the individual XML elements within the list. When defined alongside `type` being `array` (outside the `items`), it will affect the wrapping element and only if `wrapped` is `true`. If `wrapped` is `false`, it will be ignored.
<a name="xmlNamespace"></a>namespace | `string` | The URI of the namespace definition. Value MUST be in the form of an absolute URI.
<a name="xmlPrefix"></a>prefix | `string` | The prefix to be used for the [name](#xmlName).
<a name="xmlAttribute"></a>attribute | `boolean` | Declares whether the property definition translates to an attribute instead of an element. Default value is `false`.
<a name="xmlWrapped"></a>wrapped | `boolean` | MAY be used only for an array definition. Signifies whether the array is wrapped (for example, `<books><book/><book/></books>`) or unwrapped (`<book/><book/>`). Default value is `false`. The definition takes effect only when defined alongside `type` being `array` (outside the `items`).

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### XML 對象示例　

The examples of the XML object definitions are included inside a property definition of a [Schema Object](#schemaObject) with a sample of the XML representation of it.

###### No XML Element

Basic string property:

```json
{
    "animals": {
        "type": "string"
    }
}
```

```yaml
animals:
  type: string
```

```xml
<animals>...</animals>
```

Basic string array property ([`wrapped`](#xmlWrapped) is `false` by default):

```json
{
    "animals": {
        "type": "array",
        "items": {
            "type": "string"
        }
    }
}
```

```yaml
animals:
  type: array
  items:
    type: string
```

```xml
<animals>...</animals>
<animals>...</animals>
<animals>...</animals>
```

###### XML Name Replacement

```json
{
  "animals": {
    "type": "string",
    "xml": {
      "name": "animal"
    }
  }
}
```

```yaml
animals:
  type: string
  xml:
    name: animal
```

```xml
<animal>...</animal>
```


###### XML Attribute, Prefix and Namespace

In this example, a full model definition is shown.

```json
{
  "Person": {
    "type": "object",
    "properties": {
      "id": {
        "type": "integer",
        "format": "int32",
        "xml": {
          "attribute": true
        }
      },
      "name": {
        "type": "string",
        "xml": {
          "namespace": "http://example.com/schema/sample",
          "prefix": "sample"
        }
      }
    }
  }
}
```

```yaml
Person:
  type: object
  properties:
    id:
      type: integer
      format: int32
      xml:
        attribute: true
    name:
      type: string
      xml:
        namespace: http://example.com/schema/sample
        prefix: sample
```

```xml
<Person id="123">
    <sample:name xmlns:sample="http://example.com/schema/sample">example</sample:name>
</Person>
```

###### XML Arrays

Changing the element names:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
```

```xml
<animal>value</animal>
<animal>value</animal>
```

The external `name` property has no effect on the XML:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens"
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
```

```xml
<animal>value</animal>
<animal>value</animal>
```

Even when the array is wrapped, if a name is not explicitly defined, the same name will be used both internally and externally:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    wrapped: true
```

```xml
<animals>
  <animals>value</animals>
  <animals>value</animals>
</animals>
```

To overcome the naming problem in the example above, the following definition can be used:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    wrapped: true
```

```xml
<animals>
  <animal>value</animal>
  <animal>value</animal>
</animals>
```

Affecting both internal and external names:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <animal>value</animal>
  <animal>value</animal>
</aliens>
```

If we change the external element but not the internal ones:

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <aliens>value</aliens>
  <aliens>value</aliens>
</aliens>
```

#### <a name="securitySchemeObject"></a>Security Scheme 對象

定義一個用於 operations 的 security scheme。被支持的 schemes 有 HTTP 認證，一個 API key（作為 header 或 query parameter），定義於[RFC6749](https://tools.ietf.org/html/rfc6749) 的 Oauth2 常用流程（implicit、password、application 和 access code）和 [OpenID Connect Discovery](https://tools.ietf.org/html/draft-ietf-oauth-discovery-06)。

##### 固定字段
字段名 | 類型 | Applies To | 描述
---|:---:|---|---
<a name="securitySchemeType"></a>type | `string` | Any | **必選**. security scheme 的類型。有效值包括 `"apiKey"`, `"http"`, `"oauth2"`, `"openIdConnect"`.
<a name="securitySchemeDescription"></a>description | `string` | Any | 對 security scheme 的簡短描述. [CommonMark syntax](http://spec.commonmark.org/)可以被用來呈現富文本格式.
<a name="securitySchemeName"></a>name | `string` | `apiKey` | **必選**. 用於 header、 query 或 cookie 的參數名字。
<a name="securitySchemeIn"></a>in | `string` | `apiKey` | **必選**. API key 的位置。有效值包括 `"query"`、`"header"` 或 `"cookie"`.
<a name="securitySchemeScheme"></a>scheme | `string` | `http` | **必選**. 用於 [Authorization header as defined in RFC7235](https://tools.ietf.org/html/rfc7235#section-5.1) 的 HTTP Auahorization scheme 的名字.
<a name="securitySchemeBearerFormat"></a>bearerFormat | `string` | `http` (`"bearer"`) | 用於提示客戶端所使用的bearer token的格式。Bearer token 通常通過一個authorization server生成，所以這個字段最主要的目的是用來記錄這個信息。
<a name="securitySchemeFlows"></a>flows | [OAuth Flows Object](#oauthFlowsObject) | `oauth2` | **必選**. 一個包含所支持的 flow types 的配置信息的對象。
<a name="securitySchemeOpenIdConnectUrl"></a>openIdConnectUrl | `string` | `openIdConnect` | **必選**. 用於發現 OAuth2 配置值的OpenId Connect URL，必須是 URL 形式。

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### Security Scheme 對象示例

###### Basic Authentication Sample

```json
{
  "type": "http",
  "scheme": "basic"
}
```

```yaml
type: http
scheme: basic
```

###### API Key Sample

```json
{
  "type": "apiKey",
  "name": "api_key",
  "in": "header"
}
```

```yaml
type: apiKey
name: api_key
in: header
```

###### JWT Bearer Sample

```json
{
  "type": "http",
  "scheme": "bearer",
  "bearerFormat": "JWT",
}
```

```yaml
type: http
scheme: bearer
bearerFormat: JWT
```

###### Implicit OAuth2 Sample

```json
{
  "type": "oauth2",
  "flows": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    }
  }
}
```

```yaml
type: oauth2
flows:
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets
```

#### <a name="oauthFlowsObject"></a>OAuth Flows Object

Allows configuration of the supported OAuth Flows.

##### 固定字段
字段名 | 類型 | 描述
---|:---:|---
<a name="oauthFlowsImplicit"></a>implicit| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Implicit flow
<a name="oauthFlowsPassword"></a>password| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Resource Owner Password flow
<a name="oauthFlowsClientCredentials"></a>clientCredentials| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Client Credentials flow.  Previously called `application` in OpenAPI 2.0.
<a name="oauthFlowsAuthorizationCode"></a>authorizationCode| [OAuth Flow Object](#oauthFlowObject) | Configuration for the OAuth Authorization Code flow.  Previously called `accessCode` in OpenAPI 2.0.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

#### <a name="oauthFlowObject"></a>OAuth Flow Object

Configuration details for a supported OAuth Flow

##### 固定字段
字段名 | 類型 | Applies To | 描述
---|:---:|---|---
<a name="oauthFlowAuthorizationUrl"></a>authorizationUrl | `string` | `oauth2` (`"implicit"`, `"authorizationCode"`) | **必選**. The authorization URL to be used for this flow. This MUST be in the form of a URL.
<a name="oauthFlowTokenUrl"></a>tokenUrl | `string` | `oauth2` (`"password"`, `"clientCredentials"`, `"authorizationCode"`) | **必選**. The token URL to be used for this flow. This MUST be in the form of a URL.
<a name="oauthFlowRefreshUrl"></a>refreshUrl | `string` | `oauth2` | The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL.
<a name="oauthFlowScopes"></a>scopes | Map[`string`, `string`] | `oauth2` | **必選**. The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.

這個對象可能會被[規範擴展](#specificationExtensions)擴展。

##### OAuth Flow 對象示例s

```JSON
{
  "type": "oauth2",
  "flows": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    },
    "authorizationCode": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "tokenUrl": "https://example.com/api/oauth/token",
      "scopes": {
        "write:pets": "modify pets in your account",
        "read:pets": "read your pets"
      }
    }
  }
}
```

```YAML
type: oauth2
flows:
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets
  authorizationCode:
    authorizationUrl: https://example.com/api/oauth/dialog
    tokenUrl: https://example.com/api/oauth/token
    scopes:
      write:pets: modify pets in your account
      read:pets: read your pets
```


#### <a name="securityRequirementObject"></a>Security Requirement 對象

列出執行此 operation 所需的 security schemes。每個屬性的名字都必須與
 [Components Object](#componentsObject) 中 [Security Schemes](#componentsSecuritySchemes) 聲明的 security scheme 相符。

包含多個 schemes 的 Security Requirement 對象中的所有 scheme 都必須要滿足授權請求。這便能夠支持需要使用多個 query parameters 或 HTTP headers 來傳遞安全信息的情景。

When a list of Security Requirement Objects is defined on the [Open API object](#oasObject) or [Operation Object](#operationObject), only one of Security Requirement Objects in the list needs to be satisfied to authorize the request.

##### 模式字段

字段名模式 | 類型 | 描述
---|:---:|---
<a name="securityRequirementsName"></a>{name} | [`string`] | Each name MUST correspond to a security scheme which is declared in the [Security Schemes](#componentsSecuritySchemes) under the [Components Object](#componentsObject). If the security scheme is of type `"oauth2"` or `"openIdConnect"`, then the value is a list of scope names required for the execution. For other security scheme types, the array MUST be empty.

##### Security Requirement 對象示例

###### Non-OAuth2 Security Requirement

```json
{
  "api_key": []
}
```

```yaml
api_key: []
```

###### OAuth2 Security Requirement

```json
{
  "petstore_auth": [
    "write:pets",
    "read:pets"
  ]
}
```

```yaml
petstore_auth:
- write:pets
- read:pets
```

### <a name="specificationExtensions"></a>規範擴展

While the OpenAPI Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points.

The extensions properties are implemented as patterned fields that are always prefixed by `"x-"`.

字段名模式 | 類型 | 描述
---|:---:|---
<a name="infoExtensions"></a>^x- | Any | Allows extensions to the OpenAPI Schema. The field name MUST begin with `x-`, for example, `x-internal-id`. The value can be `null`, a primitive, an array or an object. Can have any valid JSON format value.

The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced).

### <a name="securityFiltering"></a>Security Filtering

Some objects in the OpenAPI Specification MAY be declared and remain empty, or be completely removed, even though they are inherently the core of the API documentation.

The reasoning is to allow an additional layer of access control over the documentation.
While not part of the specification itself, certain libraries MAY choose to allow access to parts of the documentation based on some form of authentication/authorization.

Two examples of this:

1. The [Paths Object](#pathsObject) MAY be empty. It may be counterintuitive, but this may tell the viewer that they got to the right place, but can't access any documentation. They'd still have access to the [Info Object](#infoObject) which may contain additional information regarding authentication.
2. The [Path Item Object](#pathItemObject) MAY be empty. In this case, the viewer will be aware that the path exists, but will not be able to see any of its operations or parameters. This is different than hiding the path itself from the [Paths Object](#pathsObject), so the user will not be aware of its existence. This allows the documentation provider to finely control what the viewer can see.

## <a name="revisionHistory"></a>Appendix A: Revision History

Version   | Date       | Notes
---       | ---        | ---
3.0.0     | 2017-07-26 | Release of the OpenAPI Specification 3.0.0
3.0.0-rc2 | 2017-06-16 | rc2 of the 3.0 specification
3.0.0-rc1 | 2017-04-27 | rc1 of the 3.0 specification
3.0.0-rc0 | 2017-02-28 | Implementer's Draft of the 3.0 specification
2.0       | 2015-12-31 | Donation of Swagger 2.0 to the Open API Initiative
2.0       | 2014-09-08 | Release of Swagger 2.0
1.2       | 2014-03-14 | Initial release of the formal document.
1.1       | 2012-08-22 | Release of Swagger 1.1
1.0       | 2011-08-10 | First release of the Swagger Specification
